/* SPDX-License-Identifier: LGPL-2.1-or-later */
/*
 * Copyright (C) 2017 Red Hat, Inc.
 */

#include "libnm-glib-aux/nm-default-glib-i18n-lib.h"

#include "nm-random-utils.h"

#include <fcntl.h>
#include <sys/auxv.h>

#if USE_SYS_RANDOM_H
    #include <sys/random.h>
#else
    #include <linux/random.h>
#endif

#include "nm-shared-utils.h"
#include "nm-time-utils.h"

/*****************************************************************************/

static GRand *
_rand_create_global(void)
{
    GRand *       rand1;
    guint32       seed_array[16 + 2 + 4 + 2 + 2];
    int           seed_idx;
    const guint8 *p_at_random;
    guint64       now_nsec;

    /* We only call this once, and only in case where getrandom()/urandom
     * already failed. Let's try hard to get a good seed.
     *
     * We also don't want to use glib's singleton GRand instance, because
     * our code should not consume random numbers from that instance. */

    rand1 = g_rand_new();

    /* Get some seed material by using GRand. g_rand_new() is itself seeded
     * from /dev/urandom (good, but we are already in a scenario where that
     * failed) or fallback to the time/pid (not so good). */
    for (seed_idx = 0; seed_idx < 16; seed_idx++)
        seed_array[seed_idx] = g_rand_int(rand1);

    /* Add an address from the heap. */
    seed_array[seed_idx++] = ((guint64) ((uintptr_t) ((gpointer) rand1))) >> 32;
    seed_array[seed_idx++] = ((guint64) ((uintptr_t) ((gpointer) rand1)));

    g_rand_free(rand1);

    /* Add the per-process, random number. */
    p_at_random = ((gpointer) getauxval(AT_RANDOM));
    if (p_at_random) {
        G_STATIC_ASSERT(sizeof(guint32) == 4);
        memcpy(&seed_array[seed_idx], p_at_random, 16);
        seed_idx += 4;
    }

    /* Add the current timestamp, the pid and ppid. */
    now_nsec               = nm_utils_clock_gettime_nsec(CLOCK_BOOTTIME);
    seed_array[seed_idx++] = ((guint64) now_nsec) >> 32;
    seed_array[seed_idx++] = ((guint64) now_nsec);
    seed_array[seed_idx++] = getpid();
    seed_array[seed_idx++] = getppid();

    nm_assert(seed_idx <= G_N_ELEMENTS(seed_array));
    return g_rand_new_with_seed_array(seed_array, seed_idx);
}

static GRand *
_rand_create_thread_local(void)
{
    G_LOCK_DEFINE_STATIC(global_rand);
    static GRand *global_rand = NULL;
    guint32       seed_buffer[16];
    gsize         i;

    /* For our global_rand instance we use a seed derived from getauxval(AT_RANDOM)
     * or the PID, which don't change per process. So that is not a good source
     * to initialize multiple GRand instances (for each thread).
     *
     * Instead, we use the random numbers generated by global_rand to
     * seed the thread local instances. */

    G_LOCK(global_rand);

    if (G_UNLIKELY(!global_rand))
        global_rand = _rand_create_global();

    for (i = 0; i < G_N_ELEMENTS(seed_buffer); i++)
        seed_buffer[i] = g_rand_int(global_rand);

    G_UNLOCK(global_rand);

    return g_rand_new_with_seed_array(seed_buffer, G_N_ELEMENTS(seed_buffer));
}

/**
 * nm_utils_random_bytes:
 * @p: the buffer to fill
 * @n: the number of bytes to write to @p.
 *
 * Uses getrandom() or reads /dev/urandom to fill the buffer
 * with random data. If all fails, as last fallback it uses
 * GRand to fill the buffer with pseudo random numbers.
 * The function always succeeds in writing some random numbers
 * to the buffer. The return value of FALSE indicates that the
 * obtained bytes are probably not of good randomness.
 *
 * Returns: whether the written bytes are good. If you
 * don't require good randomness, you can ignore the return
 * value.
 *
 * Note that if calling getrandom() fails because there is not enough
 * entropy (at early boot), the function will read /dev/urandom.
 * Which of course, still has low entropy, and cause kernel to log
 * a warning.
 */
gboolean
nm_utils_random_bytes(void *p, size_t n)
{
    int      fd;
    int      r;
    gboolean has_high_quality = TRUE;
    gboolean urandom_success;
    guint8 * buf           = p;
    gboolean avoid_urandom = FALSE;

    g_return_val_if_fail(p, FALSE);
    g_return_val_if_fail(n > 0, FALSE);

#if HAVE_GETRANDOM
    {
        static gboolean have_syscall = TRUE;

        if (have_syscall) {
            r = getrandom(buf, n, GRND_NONBLOCK);
            if (r > 0) {
                if ((size_t) r == n)
                    return TRUE;

                /* no or partial read. There is not enough entropy.
                 * Fill the rest reading from urandom, and remember that
                 * some bits are not high quality. */
                nm_assert(r < n);
                buf += r;
                n -= r;
                has_high_quality = FALSE;

                /* At this point, we don't want to read /dev/urandom, because
                 * the entropy pool is low (early boot?), and asking for more
                 * entropy causes kernel messages to be logged.
                 *
                 * We use our fallback via GRand. Note that g_rand_new() also
                 * tries to seed itself with data from /dev/urandom, but since
                 * we reuse the instance, it shouldn't matter. */
                avoid_urandom = TRUE;
            } else {
                if (errno == ENOSYS) {
                    /* no support for getrandom(). We don't know whether
                     * we urandom will give us good quality. Assume yes. */
                    have_syscall = FALSE;
                } else {
                    /* unknown error. We'll read urandom below, but we don't have
                     * high-quality randomness. */
                    has_high_quality = FALSE;
                }
            }
        }
    }
#endif

    urandom_success = FALSE;
    if (!avoid_urandom) {
fd_open:
        fd = open("/dev/urandom", O_RDONLY | O_CLOEXEC | O_NOCTTY);
        if (fd < 0) {
            r = errno;
            if (r == EINTR)
                goto fd_open;
        } else {
            r = nm_utils_fd_read_loop_exact(fd, buf, n, TRUE);
            nm_close(fd);
            if (r >= 0)
                urandom_success = TRUE;
        }
    }

    if (!urandom_success) {
        static _nm_thread_local GRand *rand_tls = NULL;
        GRand *                        rand;
        gsize                          i;
        int                            j;

        /* we failed to fill the bytes reading from urandom.
         * Fill the bits using GRand pseudo random numbers.
         *
         * We don't have good quality.
         */
        has_high_quality = FALSE;

        rand = rand_tls;
        if (G_UNLIKELY(!rand)) {
            rand     = _rand_create_thread_local();
            rand_tls = rand;
            nm_utils_thread_local_register_destroy(rand, (GDestroyNotify) g_rand_free);
        }

        nm_assert(n > 0);
        i = 0;
        for (;;) {
            const union {
                guint32 v32;
                guint8  v8[4];
            } v = {
                .v32 = g_rand_int(rand),
            };

            for (j = 0; j < 4;) {
                buf[i++] = v.v8[j++];
                if (i >= n)
                    goto done;
            }
        }
done:;
    }

    return has_high_quality;
}
